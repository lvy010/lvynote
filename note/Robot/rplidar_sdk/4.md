# ç¬¬å››ç« ï¼šğŸ¢å¼‚æ­¥æ”¶å‘å™¨å’Œåè®®ç¼–è§£ç å™¨

æ¬¢è¿å›æ¥

åœ¨[ç¬¬ä¸‰ç« ï¼šæ¿€å…‰é›·è¾¾åè®®æ•°æ®ç»“æ„](03_lidar_protocol_data_structures_.md)ä¸­ï¼Œæˆ‘ä»¬äº†è§£äº†æˆ‘ä»¬çš„è½¯ä»¶å’Œ RPLIDAR ä¼ æ„Ÿå™¨ç”¨æ¥é€šä¿¡çš„ç²¾ç¡®"è¯­è¨€"ï¼ˆå‘½ä»¤å’Œå“åº”ç»“æ„ï¼‰ã€‚æˆ‘ä»¬ç°åœ¨çŸ¥é“æ¶ˆæ¯*çœ‹èµ·æ¥*æ˜¯ä»€ä¹ˆæ ·çš„ã€‚

ä½†æ˜¯ä»…ä»…çŸ¥é“ä¸€ç§è¯­è¨€æ˜¯ä¸å¤Ÿçš„ï¼›æˆ‘ä»¬è¿˜éœ€è¦ä¸€ç§æœ‰æ•ˆåœ°*è¯´*å’Œ*å¬*å®ƒçš„æ–¹å¼ã€‚è¿™å°±æ˜¯**å¼‚æ­¥æ”¶å‘å™¨**å’Œ**åè®®ç¼–è§£ç å™¨**å‘æŒ¥ä½œç”¨çš„åœ°æ–¹ã€‚è¿™å¯¹å¼ºå¤§çš„ç»„åˆæ„æˆäº†é€šä¿¡éª¨å¹²ï¼Œç¡®ä¿æˆ‘ä»¬çš„æ¿€å…‰é›·è¾¾ä¸æˆ‘ä»¬çš„è®¡ç®—æœºé¡ºç•…é€šä¿¡ï¼Œè€Œä¸ä¼šæ‹–ç´¯æˆ‘ä»¬çš„ä¸»ç¨‹åºã€‚

### å¼‚æ­¥æ”¶å‘å™¨å’Œåè®®ç¼–è§£ç å™¨è§£å†³ä»€ä¹ˆé—®é¢˜ï¼Ÿ

æƒ³è±¡ä¸€ä¸‹æˆ‘ä»¬æ­£åœ¨å°è¯•å‘å›½å¤–å‘é€å’Œæ¥æ”¶ä¿¡ä»¶ï¼ˆå‘½ä»¤å’Œæ•°æ®ï¼‰ã€‚æˆ‘ä»¬é¢ä¸´ä¸¤ä¸ªä¸»è¦æŒ‘æˆ˜ï¼š

1.  **é‚®æ”¿æœåŠ¡ï¼ˆå‘é€/æ¥æ”¶ï¼‰ï¼š** æˆ‘ä»¬éœ€è¦ä¸€ä¸ªå¯é çš„é‚®æ”¿æœåŠ¡ï¼Œå¯ä»¥å¿«é€Ÿå‘é€æˆ‘ä»¬çš„å¤–å‘ä¿¡ä»¶å¹¶ä¸æ–­æ£€æŸ¥ä¼ å…¥é‚®ä»¶ï¼Œè€Œæ— éœ€æˆ‘ä»¬æ•´å¤©ç«™åœ¨é‚®ç®±æ—è¾¹ã€‚å¦‚æœæˆ‘ä»¬å¿…é¡»ç­‰å¾…æ¯å°ä¿¡åˆ°è¾¾åæ‰èƒ½åšå…¶ä»–äº‹æƒ…ï¼Œæˆ‘ä»¬çš„ç”Ÿæ´»ä¼šéå¸¸ç¼“æ…¢ï¼
2.  **ç¿»è¯‘ï¼ˆç†è§£è¯­è¨€ï¼‰ï¼š** ä¸€æ—¦é‚®ä»¶åˆ°è¾¾ï¼Œå®ƒæ˜¯ç”¨å¤–è¯­å†™çš„ã€‚æˆ‘ä»¬éœ€è¦ä¸€ä¸ªç†Ÿç»ƒçš„ç¿»è¯‘å°†è¿™äº›ä¼ å…¥çš„å¤–å›½ä¿¡ä»¶è½¬æ¢æˆæˆ‘ä»¬çš„è¯­è¨€ï¼Œå¹¶å°†æˆ‘ä»¬çš„å¤–å‘æ¶ˆæ¯ç¿»è¯‘æˆå¤–è¯­ä¾›é‚®æ”¿æœåŠ¡ä½¿ç”¨ã€‚

åœ¨ RPLIDAR çš„ä¸–ç•Œä¸­ï¼Œ`AsyncTransceiver` æ˜¯æˆ‘ä»¬çš„**é‚®æ”¿æœåŠ¡**ï¼Œ`ProtocolCodec` æ˜¯æˆ‘ä»¬çš„**ç¿»è¯‘**ã€‚

æ¿€å…‰é›·è¾¾ä¸æ–­æ—‹è½¬å¹¶å‘å‡ºæ¿€å…‰æŸï¼Œäº§ç”Ÿè¿ç»­çš„æ•°æ®æµã€‚æˆ‘ä»¬çš„è®¡ç®—æœºè¿˜éœ€è¦å‘é€å‘½ä»¤ï¼ˆå¦‚"å¼€å§‹æ‰«æ"ï¼‰å¹¶æ¥æ”¶å“åº”ã€‚è¿™ç§é€šä¿¡æ˜¯ï¼š
*   **è¿ç»­çš„ï¼š** ç‰¹åˆ«æ˜¯å¯¹äºæ‰«ææ•°æ®ï¼Œå®ƒæ˜¯ä¸€ä¸ªæ°¸æ— æ­¢å¢ƒçš„æµã€‚
*   **ä½çº§çš„ï¼š** å®ƒæ˜¯é€šè¿‡ä¸²å£æˆ–ç½‘ç»œçš„åŸå§‹å­—èŠ‚ï¼Œä¸å®¹æ˜“ç†è§£ã€‚
*   **æ—¶é—´æ•æ„Ÿçš„ï¼š** æˆ‘ä»¬å¸Œæœ›å°½å¿«è·å¾—æ•°æ®ã€‚

`AsyncTransceiver` å’Œ `ProtocolCodec` ååŒå·¥ä½œï¼Œé«˜æ•ˆåœ°ç®¡ç†è¿™ç§å¤æ‚ã€è¿ç»­çš„é€šä¿¡ï¼Œè€Œæ— éœ€æˆ‘ä»¬çš„ä¸»ç¨‹åºä¸æ–­ç›‘è§†é€šä¿¡é€šé“æˆ–æ‰‹åŠ¨è§£ç åŸå§‹å­—èŠ‚ã€‚è¿™ç¡®ä¿äº†**æµç•…ã€é«˜æ•ˆå’Œéé˜»å¡çš„é€šä¿¡**ã€‚

### "é‚®æ”¿æœåŠ¡"å’Œ"ç¿»è¯‘"ç±»æ¯”

è®©æˆ‘ä»¬ç”¨æˆ‘ä»¬çš„ç±»æ¯”æ¥åˆ†è§£è¿™ä¸¤ä¸ªç»„ä»¶ï¼š

| ç»„ä»¶                 | ç±»æ¯”                 | åœ¨ RPLIDAR SDK ä¸­çš„è§’è‰²                                      |
| :------------------- | :------------------- | :----------------------------------------------------------- |
| **AsyncTransceiver** | é‚®æ”¿æœåŠ¡             | åœ¨åå°çº¿ç¨‹ä¸­ä¸æ–­ä»[é€šä¿¡é€šé“ (IChannel)](05_communication_channel__ichannel__.md)è¯»å–åŸå§‹æ•°æ®å—ï¼Œå¹¶å‘å…¶å‘é€åŸå§‹å‘½ä»¤å­—èŠ‚ã€‚å®ƒç¡®ä¿è¿ç»­çš„æ•°æ®æµè€Œä¸ä¼šé˜»å¡æˆ‘ä»¬çš„ä¸»ç¨‹åºã€‚ |
| **ProtocolCodec**    | ç¿»è¯‘                 | æ¥æ”¶ `AsyncTransceiver` æ¥æ”¶çš„åŸå§‹å­—èŠ‚ï¼Œå¹¶å°†å®ƒä»¬è§£é‡Šä¸ºæœ‰æ„ä¹‰çš„ `ProtocolMessage` å¯¹è±¡ï¼ˆç¿»è¯‘æ¿€å…‰é›·è¾¾çš„"è¯­è¨€"ï¼‰ã€‚å®ƒè¿˜å°†å¤–å‘çš„ `ProtocolMessage` å¯¹è±¡è½¬æ¢ä¸ºç”¨äºå‘é€çš„åŸå§‹å­—èŠ‚ã€‚ |
| **ProtocolMessage**  | æ ‡å‡†ä¿¡ä»¶ï¼ˆåœ¨ä¼ è¾“ä¸­ï¼‰ | ä¸€ä¸ªé€šç”¨çš„ã€ç»“æ„åŒ–çš„ä¿¡å°ï¼Œåœ¨ç¿»è¯‘ä¹‹å‰æˆ–ä¹‹åä»¥æ ‡å‡†åŒ–æ ¼å¼ä¿å­˜å¤–å‘å‘½ä»¤æˆ–ä¼ å…¥å“åº”ã€‚ |

### æ¦‚å¿µ 1ï¼š`AsyncTransceiver`ï¼ˆæˆ‘ä»¬çš„åå°é‚®æ”¿æœåŠ¡ï¼‰

`AsyncTransceiver` è´Ÿè´£é€šè¿‡ç‰©ç†è¿æ¥ï¼ˆå¦‚ USB ä¸²å£ï¼‰å®é™…å‘é€å’Œæ¥æ”¶æ•°æ®ã€‚"Async"éƒ¨åˆ†è‡³å…³é‡è¦ï¼šå®ƒæ„å‘³ç€**å¼‚æ­¥**ï¼Œè¿™æ„å‘³ç€å®ƒåœ¨åå°å®Œæˆå·¥ä½œï¼Œé‡Šæ”¾æˆ‘ä»¬çš„ä¸»ç¨‹åºå»åšå…¶ä»–äº‹æƒ…ã€‚

å®ƒé€šå¸¸ä½¿ç”¨ä¸¤ä¸ªå†…éƒ¨çº¿ç¨‹ï¼š
*   **RX çº¿ç¨‹ï¼ˆä¼ å…¥é‚®ä»¶ï¼‰ï¼š** æ­¤çº¿ç¨‹ä¸æ–­ç›‘è§†[é€šä¿¡é€šé“ (IChannel)](05_communication_channel__ichannel__.md)ä»¥è·å–ä¼ å…¥çš„åŸå§‹æ•°æ®ã€‚å½“æ•°æ®åˆ°è¾¾æ—¶ï¼Œå®ƒæŠ“å–åŸå§‹å­—èŠ‚å¹¶å°†å®ƒä»¬æ”¾å…¥å†…éƒ¨é˜Ÿåˆ—ï¼Œå°±åƒé‚®é€’å‘˜ä»è®¸å¤šé‚®ç®±æ”¶é›†ä¿¡ä»¶å¹¶å°†å®ƒä»¬å¸¦å›é‚®å±€ã€‚
*   **è§£ç å™¨çº¿ç¨‹ï¼ˆåˆ†æ‹£ä¼ å…¥é‚®ä»¶ï¼‰ï¼š** æ­¤çº¿ç¨‹ä¸æ–­ä» RX çº¿ç¨‹å¡«å……çš„é˜Ÿåˆ—ä¸­è·å–åŸå§‹æ•°æ®å—ï¼Œå¹¶å°†å®ƒä»¬ä¼ é€’ç»™ `ProtocolCodec` è¿›è¡Œç¿»è¯‘ã€‚è¿™å°±åƒé‚®å±€å·¥ä½œäººå‘˜å°†æ”¶é›†çš„é‚®ä»¶åˆ†æ‹£åˆ°ä¸åŒçš„ç®±å­ä¸­ã€‚

`AsyncTransceiver` ä¸ç†è§£å­—èŠ‚çš„*å«ä¹‰*ï¼›å®ƒåªå¤„ç†å®ƒä»¬çš„ç§»åŠ¨ã€‚

### æ¦‚å¿µ 2ï¼š`ProtocolCodec`ï¼ˆæˆ‘ä»¬çš„ä¸“èŒç¿»è¯‘ï¼‰

`ProtocolCodec` æ˜¯ç†è§£ RPLIDAR "è¯­è¨€"ï¼ˆæˆ‘ä»¬åœ¨ç¬¬ä¸‰ç« ä¸­è®¨è®ºçš„[æ¿€å…‰é›·è¾¾åè®®æ•°æ®ç»“æ„](03_lidar_protocol_data_structures_.md)ï¼‰çš„å¤§è„‘ã€‚å®ƒæ‰§è¡Œä¸¤ä¸ªä¸»è¦åŠŸèƒ½ï¼š

*   **ç¼–ç ï¼ˆç¿»è¯‘å¤–å‘å‘½ä»¤ï¼‰ï¼š** å½“æˆ‘ä»¬çš„ `ILidarDriver` æƒ³è¦å‘é€å‘½ä»¤ï¼ˆå¦‚"è·å–è®¾å¤‡ä¿¡æ¯"ï¼‰æ—¶ï¼Œå®ƒä¼šåˆ›å»ºä¸€ä¸ª `ProtocolMessage`ã€‚`ProtocolCodec` æ¥æ”¶æ­¤ `ProtocolMessage` å¹¶å°†å…¶è½¬æ¢ä¸ºæ¿€å…‰é›·è¾¾ç†è§£çš„ç¡®åˆ‡åŸå§‹å­—èŠ‚åºåˆ—ï¼Œæ·»åŠ åŒæ­¥å­—èŠ‚ã€å¤§å°ã€æ ¡éªŒå’Œç­‰ã€‚
*   **è§£ç ï¼ˆç¿»è¯‘ä¼ å…¥å“åº”ï¼‰ï¼š** å½“ `AsyncTransceiver` ä»æ¿€å…‰é›·è¾¾æ¥æ”¶åŸå§‹å­—èŠ‚æ—¶ï¼Œå®ƒå°†å®ƒä»¬é¦ˆé€ç»™ `ProtocolCodec`ã€‚ç„¶åï¼Œ`ProtocolCodec` æ™ºèƒ½åœ°è§£æè¿™äº›å­—èŠ‚ï¼Œè¯†åˆ«å®ƒä»¬çš„ç±»å‹ï¼ŒéªŒè¯å®ƒä»¬ï¼ˆä¾‹å¦‚ï¼Œæ ¡éªŒå’Œï¼‰ï¼Œå¹¶å°†å®ƒä»¬é‡å»ºä¸ºæœ‰æ„ä¹‰çš„ `ProtocolMessage` å¯¹è±¡ã€‚ä¸€æ—¦å®Œæ•´çš„æ¶ˆæ¯è¢«è§£ç ï¼Œå®ƒå°±ä¼šé€šçŸ¥"ç›‘å¬å™¨"ï¼ˆé€šå¸¸æ˜¯ `ILidarDriver`ï¼‰ã€‚

### æ¦‚å¿µ 3ï¼š`ProtocolMessage`ï¼ˆæ ‡å‡†åŒ–ä¿¡å°ï¼‰

`ProtocolMessage` æ˜¯ SDK *å†…éƒ¨*ä½¿ç”¨çš„ç®€å•ã€æ ‡å‡†åŒ–å®¹å™¨ï¼Œç”¨äºè¡¨ç¤ºå‘½ä»¤æˆ–å“åº”ã€‚å®ƒæ˜¯ `AsyncTransceiver` ä¼ é€’ç»™ `ProtocolCodec` çš„é€šç”¨æ ¼å¼ï¼Œä¹Ÿæ˜¯ `ProtocolCodec` ç”Ÿæˆæˆ–æ¶ˆè´¹çš„å†…å®¹ã€‚

å®ƒé€šå¸¸åŒ…å«ï¼š
*   `cmd`ï¼šè¡¨ç¤ºå¤–å‘æ¶ˆæ¯çš„å‘½ä»¤ä»£ç æˆ–ä¼ å…¥æ¶ˆæ¯çš„å“åº”ç±»å‹çš„å•ä¸ªå­—èŠ‚ã€‚
*   `len`ï¼šå®é™…æ•°æ®æœ‰æ•ˆè½½è·çš„å¤§å°ã€‚
*   `data`ï¼šæŒ‡å‘æ„æˆå®é™…æœ‰æ•ˆè½½è·çš„åŸå§‹å­—èŠ‚çš„æŒ‡é’ˆï¼ˆä¾‹å¦‚ï¼Œè®¾å¤‡ä¿¡æ¯ç»“æ„æˆ–æ‰«ææ•°æ®ï¼‰ã€‚

å°†å…¶è§†ä¸ºé€šç”¨ä¿¡ä»¶æ¨¡æ¿ï¼šå®ƒæœ‰å‘ä»¶äºº/æ”¶ä»¶äººåœ°å€ï¼ˆ`cmd`ï¼‰ã€ä¿¡ä»¶é•¿åº¦ï¼ˆ`len`ï¼‰å’Œä¿¡ä»¶çš„å®é™…å†…å®¹ï¼ˆ`data`ï¼‰ã€‚`ProtocolCodec` å¡«å……æˆ–è¯»å–è¿™äº›å­—æ®µã€‚

### å¦‚ä½•ä½¿ç”¨ï¼ˆæˆ–è€…æ›´ç¡®åˆ‡åœ°è¯´ï¼Œç†è§£ï¼‰è¿™ç§æŠ½è±¡

ä½œä¸ºä½¿ç”¨ `ILidarDriver` çš„åº”ç”¨ç¨‹åºå¼€å‘è€…ï¼Œæˆ‘ä»¬é€šå¸¸**ä¸ç›´æ¥ä¸** `AsyncTransceiver` æˆ– `ProtocolCodec` äº¤äº’ã€‚å®ƒä»¬æ˜¯ `ILidarDriver` çš„ä½çº§å†…éƒ¨ç»„ä»¶ã€‚`ILidarDriver` åœ¨å¹•åä½¿ç”¨å®ƒä»¬æ¥æ‰§è¡Œæ‰€æœ‰å¤æ‚çš„é€šä¿¡ï¼Œå°±åƒæˆ‘ä»¬ä½¿ç”¨æ±½è½¦çš„æ–¹å‘ç›˜è€Œæ— éœ€çŸ¥é“åŠ¨åŠ›è½¬å‘æ³µçš„å·¥ä½œåŸç†ä¸€æ ·ã€‚

ç„¶è€Œï¼Œç†è§£å®ƒä»¬çš„ä½œç”¨å¯¹äºæŒæ¡ SDK çš„åŠŸèƒ½è‡³å…³é‡è¦ï¼š

*   å½“æˆ‘ä»¬è°ƒç”¨ `lidar->getDeviceInfo()` æ—¶ï¼Œ`ILidarDriver` ä¸º"è·å–è®¾å¤‡ä¿¡æ¯"å‘½ä»¤å½¢æˆä¸€ä¸ª `ProtocolMessage`ã€‚
*   è¿™ä¸ª `ProtocolMessage` è¢«äº¤ç»™ `AsyncTransceiver` å‘é€ã€‚
*   `AsyncTransceiver` å°†å…¶ä¼ é€’ç»™ `ProtocolCodec` ä»¥ç¼–ç ä¸ºåŸå§‹å­—èŠ‚ã€‚
*   è¿™äº›åŸå§‹å­—èŠ‚é€šè¿‡[é€šä¿¡é€šé“ (IChannel)](05_communication_channel__ichannel__.md)å‘é€åˆ°æ¿€å…‰é›·è¾¾ã€‚
*   å½“æ¿€å…‰é›·è¾¾å“åº”æ—¶ï¼ŒåŸå§‹å­—èŠ‚é€šè¿‡ `IChannel` è¿”å›ã€‚
*   `AsyncTransceiver` çš„ RX çº¿ç¨‹æ¥æ”¶å®ƒä»¬ã€‚
*   `AsyncTransceiver` çš„è§£ç å™¨çº¿ç¨‹å°†å®ƒä»¬ä¼ é€’ç»™ `ProtocolCodec`ã€‚
*   `ProtocolCodec` å°†åŸå§‹å­—èŠ‚è§£ç å› `ProtocolMessage`ï¼Œç„¶åé€šçŸ¥å†…éƒ¨ç›‘å¬å™¨ï¼ˆå®ƒæ˜¯ `ILidarDriver` çš„ä¸€éƒ¨åˆ†ï¼‰ã€‚
*   æœ€åï¼Œ`ILidarDriver` ä»è§£ç çš„ `ProtocolMessage` ä¸­æå–ä¿¡æ¯ï¼Œå¹¶ç»™æˆ‘ä»¬æä¾›å¹²å‡€çš„ `sl_lidar_response_device_info_t`ã€‚

ç”±äºè¿™äº›ç»„ä»¶ï¼Œæ•´ä¸ªè¿‡ç¨‹åœ¨åå°è‡ªåŠ¨å‘ç”Ÿï¼

### "åº•å±‚"å‘ç”Ÿäº†ä»€ä¹ˆï¼Ÿ

è®©æˆ‘ä»¬çœ‹çœ‹ `getDeviceInfo()` è°ƒç”¨çš„ç®€åŒ–äº‹ä»¶åºåˆ—ï¼Œé‡ç‚¹å…³æ³¨ `AsyncTransceiver` å’Œ `ProtocolCodec`ã€‚

```mermaid
sequenceDiagram
    participant App as æˆ‘ä»¬çš„åº”ç”¨ç¨‹åº
    participant Driver as ILidarDriverï¼ˆå†…éƒ¨ï¼‰
    participant Transceiver as AsyncTransceiver
    participant Codec as ProtocolCodec
    participant Channel as IChannel
    participant Lidar as RPLIDAR è®¾å¤‡

    App->>Driver: getDeviceInfo()
    Note over Driver: ä¸º"è·å–è®¾å¤‡ä¿¡æ¯"åˆ›å»º ProtocolMessage
    Driver->>Transceiver: sendMessage(command_msg)
    Note over Transceiver: ä½¿ç”¨å…¶å†…éƒ¨ç¼–è§£ç å™¨å‡†å¤‡å­—èŠ‚
    Transceiver->>Codec: onEncodeData(command_msg)
    Codec->>Channel: å‘é€åŸå§‹å‘½ä»¤å­—èŠ‚ï¼ˆä¾‹å¦‚ï¼Œ0xA5 0x50 0x00ï¼‰
    Channel->>Lidar: ä¼ è¾“å­—èŠ‚
    Lidar->>Lidar: å¤„ç†å‘½ä»¤å¹¶å‡†å¤‡å“åº”
    Lidar->>Channel: å‘é€åŸå§‹å“åº”å­—èŠ‚ï¼ˆä¾‹å¦‚ï¼Œ0xA5 0x5A ...ï¼‰
    Channel->>Transceiver: æ¥æ”¶åŸå§‹æ•°æ®ï¼ˆé€šè¿‡ RX çº¿ç¨‹ï¼‰
    Note over Transceiver: RX çº¿ç¨‹å°†åŸå§‹æ•°æ®æ”¾å…¥é˜Ÿåˆ—
    Transceiver->>Codec: onDecodeData(raw_data_chunk)ï¼ˆé€šè¿‡è§£ç å™¨çº¿ç¨‹ï¼‰
    Note over Codec: è§£æåŸå§‹å­—èŠ‚ï¼Œå°†å®ƒä»¬ç»„è£…æˆ ProtocolMessage
    Codec->>Driver: onProtocolMessageDecoded(response_msg)
    Note over Driver: å°† response_msgï¼ˆç±»å‹ 0x04ï¼‰è§£é‡Šä¸º sl_lidar_response_device_info_t
    Driver->>App: è¿”å›è®¾å¤‡ä¿¡æ¯ç»“æ„
```

#### ä»£ç 

è®©æˆ‘ä»¬çœ‹çœ‹è¿™äº›ç»„ä»¶åœ¨ SDK ä¸­æ˜¯å¦‚ä½•æ„é€ å’Œäº¤äº’çš„ã€‚

**1. `ProtocolMessage` ç»“æ„ï¼ˆ`sdk/src/sl_async_transceiver.h`ï¼‰**

è¿™æ˜¯æ¶ˆæ¯çš„æ ‡å‡†ä¿¡å°ã€‚

```cpp
// æ¥è‡ª: sdk/src/sl_async_transceiver.hï¼ˆç®€åŒ–ï¼‰
class ProtocolMessage {
public:
    size_t len;
    _u8 cmd;
protected:
    _u8* data; // å®é™…æœ‰æ•ˆè½½è·å­—èŠ‚
    // ... å…¶ä»–ç”¨äºå†…å­˜ç®¡ç†çš„å†…éƒ¨ç»†èŠ‚
public:
    ProtocolMessage(); // æ„é€ å‡½æ•°
    ProtocolMessage(_u8 cmd, const void* buffer, size_t size); // ç”¨äºå¤–å‘
    // ... å¦‚ fillData()ã€getDataBuf() ç­‰æ–¹æ³•
};
```
å½“ `ILidarDriver` æƒ³è¦å‘é€å‘½ä»¤æˆ–å½“ `ProtocolCodec` è§£ç äº†å“åº”æ—¶ï¼Œå®ƒä¼šå°†æ•°æ®åŒ…è£…åœ¨ `ProtocolMessage` ä¸­ã€‚

**2. `IAsyncProtocolCodec` æ¥å£ï¼ˆ`sdk/src/sl_async_transceiver.h`ï¼‰**

è¿™å®šä¹‰äº†ä»»ä½•åè®®ç¼–è§£ç å™¨çš„å¥‘çº¦ã€‚`RPLidarProtocolCodec`ï¼ˆå¤„ç†å®é™…çš„ RPLIDAR åè®®ï¼‰å®ç°äº†è¿™ä¸€ç‚¹ã€‚

```cpp
// æ¥è‡ª: sdk/src/sl_async_transceiver.hï¼ˆç®€åŒ–ï¼‰
class IAsyncProtocolCodec {
public:
    // å½“é€šé“å‡ºç°é”™è¯¯æ—¶è°ƒç”¨
    virtual void onChannelError(u_result errCode) {}
    // è°ƒç”¨ä»¥é‡ç½®è§£ç å™¨çŠ¶æ€
    virtual void onDecodeReset() {}
    // å½“æ¥æ”¶åˆ°åŸå§‹æ•°æ®æ—¶ç”± AsyncTransceiver è°ƒç”¨
    virtual void onDecodeData(const void* buffer, size_t size) = 0;
    // ç”± AsyncTransceiver è°ƒç”¨ä»¥äº†è§£ç¼–ç æ‰€éœ€çš„ç¼“å†²åŒºå¤§å°
    virtual size_t estimateLength(message_autoptr_t& message) = 0;
    // ç”± AsyncTransceiver è°ƒç”¨ä»¥å°† ProtocolMessage è½¬æ¢ä¸ºåŸå§‹å­—èŠ‚
    virtual void onEncodeData(message_autoptr_t& message, _u8* txbuffer, size_t* size) = 0;
};
```
æ­¤æ¥å£æ¸…æ¥šåœ°æ˜¾ç¤ºäº†"ç¿»è¯‘"çš„èŒè´£ï¼šå°† `ProtocolMessage` ç¼–ç ä¸ºåŸå§‹å­—èŠ‚ï¼Œå¹¶å°†åŸå§‹å­—èŠ‚è§£ç å›æ¶ˆæ¯ã€‚

**3. `AsyncTransceiver`ï¼ˆ`sdk/src/sl_async_transceiver.cpp` å’Œ `.h`ï¼‰**

è¿™æ˜¯ä¸­å¤®"é‚®æ”¿æœåŠ¡"ã€‚å®ƒåœ¨å…¶æ„é€ å‡½æ•°ä¸­æ¥æ”¶ä¸€ä¸ª `IAsyncProtocolCodec`ã€‚

```cpp
// æ¥è‡ª: sdk/src/sl_async_transceiver.hï¼ˆç®€åŒ–ï¼‰
class AsyncTransceiver {
public:
    AsyncTransceiver(IAsyncProtocolCodec& codec); // æ¥æ”¶å…¶ç¿»è¯‘çš„å¼•ç”¨
    u_result openChannelAndBind(IChannel* channel);
    u_result sendMessage(message_autoptr_t& msg); // ç”¨äºå‘é€å‘½ä»¤
protected:
    sl_result _proc_rxThread();     // RX çº¿ç¨‹å‡½æ•°
    sl_result _proc_decoderThread(); // è§£ç å™¨çº¿ç¨‹å‡½æ•°
private:
    IChannel* _bindedChannel;
    IAsyncProtocolCodec& _codec; // ç¿»è¯‘å®ä¾‹
    rp::hal::Thread _rxThread;
    rp::hal::Thread _decoderThread;
    // ... å†…éƒ¨é˜Ÿåˆ—å’Œé”
};
```

è®©æˆ‘ä»¬çœ‹çœ‹å‘é€æ¶ˆæ¯çš„æ ¸å¿ƒï¼š

```cpp
// æ¥è‡ª: sdk/src/sl_async_transceiver.cppï¼ˆç®€åŒ–ï¼‰
u_result AsyncTransceiver::sendMessage(message_autoptr_t& msg) {
    // ... æ£€æŸ¥æ˜¯å¦å·¥ä½œ ...
    size_t requiredBufferSize = _codec.estimateLength(msg); // è¯¢é—®ç¼–è§£ç å™¨ç¼“å†²åŒºå¤§å°
    _u8* txBuffer = new _u8[requiredBufferSize];
    _codec.onEncodeData(msg, txBuffer, &requiredBufferSize); // ç¼–è§£ç å™¨å¡«å……ç¼“å†²åŒº
    int txSize = _bindedChannel->write(txBuffer, requiredBufferSize); // é€šè¿‡é€šé“å‘é€
    delete[] txBuffer;
    return (txSize < 0) ? RESULT_OPERATION_FAIL : RESULT_OK;
}
```
åœ¨è¿™é‡Œï¼Œ`AsyncTransceiver` å°†ç¼–ç ä»»åŠ¡å§”æ‰˜ç»™å…¶ `_codec`ï¼Œç„¶åä½¿ç”¨ `_bindedChannel` å‘é€åŸå§‹å­—èŠ‚ã€‚

`_proc_rxThread` å’Œ `_proc_decoderThread` æ˜¯åå°çº¿ç¨‹ã€‚`_proc_rxThread` åªæ˜¯ä»é€šé“è¯»å–ï¼š
```cpp
// æ¥è‡ª: sdk/src/sl_async_transceiver.cppï¼ˆç®€åŒ–ï¼‰
sl_result AsyncTransceiver::_proc_rxThread() {
    while (_isWorking) {
        size_t hintedSize = 0;
        _bindedChannel->waitForDataExt(hintedSize, 1000); // ç­‰å¾…ä¼ å…¥æ•°æ®
        if (hintedSize) {
            Buffer* decodeBuffer = new Buffer(); // åˆ†é…ç¼“å†²åŒº
            decodeBuffer->data = new _u8[hintedSize];
            decodeBuffer->size = _bindedChannel->read(decodeBuffer->data, hintedSize); // è¯»å–åŸå§‹å­—èŠ‚
            _rxLocker.lock();
            _rxQueue.push_back(decodeBuffer); // æ·»åŠ åˆ°é˜Ÿåˆ—
            _dataEvt.set(); // é€šçŸ¥è§£ç å™¨çº¿ç¨‹
            _rxLocker.unlock();
        }
    }
    return RESULT_OK;
}
```
`_proc_decoderThread` ä»é˜Ÿåˆ—ä¸­è·å–æ•°æ®å¹¶å°†å…¶ä¼ é€’ç»™ `_codec`ï¼š
```cpp
// æ¥è‡ª: sdk/src/sl_async_transceiver.cppï¼ˆç®€åŒ–ï¼‰
sl_result AsyncTransceiver::_proc_decoderThread() {
    _codec.onDecodeReset(); // é‡ç½®ç¼–è§£ç å™¨çš„å†…éƒ¨çŠ¶æ€
    while (_isWorking) {
        // ... ç­‰å¾… _rxQueue ä¸­çš„æ•°æ® ...
        Buffer* bufferToDecode = _rxQueue.front();
        _rxQueue.pop_front();
        _codec.onDecodeData(bufferToDecode->data, bufferToDecode->size); // å°†åŸå§‹æ•°æ®ä¼ é€’ç»™ç¼–è§£ç å™¨
        delete bufferToDecode;
    }
    return RESULT_OK;
}
```

**4. `RPLidarProtocolCodec` å®ç°ï¼ˆ`sdk/src/sl_lidarprotocol_codec.cpp` å’Œ `.h`ï¼‰**

æ­¤ç±»å®ç° `IAsyncProtocolCodec` å¹¶åŒ…å«ç¿»è¯‘ RPLIDAR åè®®çš„å®é™…é€»è¾‘ã€‚å®ƒæœ‰ä¸€ä¸ªå†…éƒ¨çŠ¶æ€æœºæ¥è§£æä¼ å…¥çš„å­—èŠ‚ã€‚

```cpp
// æ¥è‡ª: sdk/src/sl_lidarprotocol_codec.hï¼ˆç®€åŒ–ï¼‰
class RPLidarProtocolCodec : public IAsyncProtocolCodec {
public:
    // ... æ„é€ å‡½æ•°ã€å…¶ä»–æ–¹æ³•
    virtual void onDecodeData(const void* buffer, size_t size); // æ ¸å¿ƒè§£ç é€»è¾‘
    void setMessageListener(IProtocolMessageListener* l); // é€šçŸ¥ ILidarDriver
protected:
    IProtocolMessageListener* _listener; // è§£ç æ¶ˆæ¯æ—¶é€šçŸ¥è°
    ProtocolMessage _decodingMessage;     // å­˜å‚¨æ­£åœ¨ç»„è£…çš„æ¶ˆæ¯
    _u32 _working_states;                  // å†…éƒ¨çŠ¶æ€ï¼ˆä¾‹å¦‚ï¼Œç­‰å¾…åŒæ­¥å­—èŠ‚ 1ï¼Œç„¶å 2ï¼Œç„¶åå¤§å°...ï¼‰
    int _rx_pos;
};
```

`onDecodeData` æ–¹æ³•å¾ˆå¤æ‚ï¼Œå› ä¸ºå®ƒé€å­—èŠ‚è¯»å–ï¼Œæ£€æŸ¥åŒæ­¥å­—ï¼Œè¯»å–å¤§å°ï¼Œç„¶åæ”¶é›†æœ‰æ•ˆè½½è·ã€‚å½“å®ƒæˆåŠŸè§£ç å®Œæ•´æ¶ˆæ¯æ—¶ï¼Œå®ƒä¼šé€šçŸ¥å…¶ç›‘å¬å™¨ï¼š

```cpp
// æ¥è‡ª: sdk/src/sl_lidarprotocol_codec.cppï¼ˆç®€åŒ–ï¼‰
void RPLidarProtocolCodec::onDecodeData(const void* buffer, size_t size) {
    const _u8* data = reinterpret_cast<const _u8*>(buffer);
    const _u8* dataEnd = data + size;

    while (data != dataEnd) {
        _u8 currentByte = *data;
        ++data;

        switch (_working_states & ((_u32)STATUS_LOOP_MODE_FLAG - 1)) {
            case STATUS_WAIT_SYNC1: // æ£€æŸ¥ 0xA5
                if (currentByte == RPLIDAR_ANS_SYNC_BYTE1) { _working_states = STATUS_WAIT_SYNC2; }
                break;
            case STATUS_WAIT_SYNC2: // æ£€æŸ¥ 0x5A
                if (currentByte == RPLIDAR_ANS_SYNC_BYTE2) { _working_states = STATUS_WAIT_SIZE_FLAG; _rx_pos = 0; }
                else { _working_states = STATUS_WAIT_SYNC1; } // é”™è¯¯ï¼Œé‡æ–°å¼€å§‹
                break;
            // ... æ›´å¤šçŠ¶æ€ä»¥è¯»å–å¤§å°ã€ç±»å‹å’Œæœ‰æ•ˆè½½è· ...
            case STATUS_RECV_PAYLOAD:
                _decodingMessage.getDataBuf()[_rx_pos++] = currentByte;
                if ((size_t)_rx_pos == _decodingMessage.getPayloadSize()) {
                    // å®Œæ•´æ¶ˆæ¯å·²æ¥æ”¶ï¼é€šçŸ¥ç›‘å¬å™¨ã€‚
                    if (_listener) {
                        _listener->onProtocolMessageDecoded(_decodingMessage);
                    }
                    _working_states = STATUS_WAIT_SYNC1; // ä¸ºä¸‹ä¸€æ¡æ¶ˆæ¯é‡ç½®
                    _rx_pos = 0;
                }
                break;
        }
    }
}
```
è¿™ä¸ªç®€åŒ–çš„ `onDecodeData` æ˜¾ç¤ºäº† `ProtocolCodec` å¦‚ä½•æŒç»­å¤„ç†ä¼ å…¥çš„åŸå§‹å­—èŠ‚ï¼Œé€šè¿‡çŠ¶æ€è½¬æ¢æ¥è¯†åˆ«æ¶ˆæ¯ç»“æ„ï¼ˆåŒæ­¥å­—èŠ‚ã€å¤§å°ã€ç±»å‹ï¼‰ï¼Œç„¶åæ”¶é›†æœ‰æ•ˆè½½è·ã€‚

ä¸€æ—¦å½¢æˆå®Œæ•´çš„ `ProtocolMessage`ï¼Œå®ƒå°±ä¼šè°ƒç”¨ `_listener->onProtocolMessageDecoded()` å°†ç»“æ„åŒ–æ¶ˆæ¯ä¼ é€’ç»™å…¶æ³¨å†Œçš„ç›‘å¬å™¨ï¼ˆåœ¨ SDK çš„å†…éƒ¨æ¶æ„ä¸­ï¼Œå®ƒæ˜¯ `ILidarDriver` å®ç°ï¼‰ã€‚

### ç»“è®º

`AsyncTransceiver` å’Œ `ProtocolCodec` æ˜¯ `rplidar_sdk` åƒä¸“ä¸šçš„==é‚®æ”¿æœåŠ¡å’Œç¿»è¯‘==ä¸€æ ·ååŒå·¥ä½œï¼Œä¸æ–­å‘é€å‘½ä»¤å’Œæ¥æ”¶åŸå§‹æ•°æ®ï¼Œç„¶åå°†è¿™äº›åŸå§‹å­—èŠ‚==è½¬æ¢==ä¸ºæœ‰æ„ä¹‰çš„ `ProtocolMessage` å¯¹è±¡ï¼ˆåä¹‹äº¦ç„¶ï¼‰ã€‚è¿™åœ¨åå°é«˜æ•ˆåœ°å‘ç”Ÿï¼Œ==ç¡®ä¿æˆ‘ä»¬çš„ä¸»åº”ç”¨ç¨‹åºå¯ä»¥ä¸“æ³¨äº*å¦‚ä½•å¤„ç†*æ¿€å…‰é›·è¾¾æ•°æ®ï¼Œè€Œä¸æ˜¯*å¦‚ä½•*ä¸ç¡¬ä»¶é€šä¿¡==ã€‚

åœ¨ä¸‹ä¸€ç« [é€šä¿¡é€šé“ (IChannel)](05_communication_channel__ichannel__.md)ä¸­ï¼Œæˆ‘ä»¬å°†æ¢ç´¢è¿™ä¸ªé€šä¿¡é“¾çš„æœ€åº•å±‚ï¼šä»£è¡¨ç‰©ç†è¿æ¥çš„æŠ½è±¡æ¥å£ï¼Œå¦‚ä¸²å£æˆ–ç½‘ç»œå¥—æ¥å­—ï¼Œ`AsyncTransceiver` ä½¿ç”¨å®ƒæ¥ç‰©ç†äº¤æ¢å­—èŠ‚ã€‚

